# Задание 2  

Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн. заказов некоторого сервиса доставки еды за некоторый период 2021 и 2022 года.
Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента, а средняя длина полного имени - 20 символов (латинских или кириллических).
Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента. Но вы не хотите оставлять следы на диске или в базе данных - придется все держать в памяти. Но еще вы не хотите зря тратить крипту на слишком большой сервер.  

Поэтому давайте оценим, сколько памяти займут эти данные:
* если мы хотим занять как можно меньше памяти?
* если мы хотим реализовать поиск за постоянное время, т.е. O(1)?
  
Считаем, что у нас 32-битная система, и ссылка занимает 4 байта.  
   
Если мы занять, как можно меньше памяти, то целесообразно хранить 
данные в массивах (так как массивы не хранят никаких дополнительных данных),
завести один массив для номеров телефонов 
`telephones`,  `names` - для полных имен. Телефон и полное имя,
принадлежащие одному человеку, находятся на позициях в массивах
с одним и тем же индексом.  

Как хранить номера телефонов? Пусть номер телефона состоит из 11 
символов. 
Поскольку номера телефонов состоят из 11 
различных символов, для хранения всех номеров будет достаточно 4 бит.
Для одного символа номера телефона хранения мы можем использовать тип 
данных `byte`, который занимает 
8 бит. В одной переменной типа `byte` можно хранить сразу два символа 
из номера телефона, с первого по 4 бит - первое число, с 5 по 8 бит - 
второе число. Тогда для хранения одного номера телефона достаточно 
массива `byte[]` размера 6. Все цифры в номере телефона положительные 
в двоичном виде 4 последних бита нулевые. Как получить такой массив 
из номера телефона? Берем первую цифру и применяем к ней операцию сдвиг 
влево, после этого 4 первых бита этой цифры будут нулевыми. После этого 
к первому числу прибавляем второе и записываем его в массив на первую 
позицию. После такого преобразования мы можем получить обратно две 
цифры, поскольку мы складываем два числа, у первого последние 4 бита 
нулевые, а у второго только последние 4 бита являются значимыми. Если 
в номер телефона входит символ '+', можно сопоставить ему число 11. 
Тогда при таком способе на хранение одного номера телефона мы потратим 
6 + 4 = 10 байт. 
  
Оценим, сколько будет занимать одно полное имя. Сожмем строку с 
полным именем и запишем ее в массив `byte`. Каждому символу сопоставим 
из строки сопоставим число: 
```Java
byte compressChar(char c) {
    if (c >= 'a' && c <= 'z')
        return c - 'a';
    if (c >= 'A' && c <= 'Z')
        return c - 'A' + 'z' - 'a' + 1;
    //Кириллица
    //Символ конца строки и т.д.
}
```
После такого сжатия полное имя будет занимать 20*1 + 4 = 24.  
   
Массивы `telephones` и `names` содержат 18 758 328 элементов. 
Массив `telephones` займет 18758328 * 10 + 4 = 187583284 байт.
Массив `names` займет 18758328 * 20 + 4 = 375166564 байт. Значит всего эти 
данные займут 187583284 + 375166564 = 562749848 байт (~563Мб).  
   
Если мы хотим обеспечить поиск полного имени по номеру телефона за О(1), 
можно использовать ассоциативный массив `HashMap<String, String>`. Внутри 
мапы находится массив, который содержит связный список, который 
состоит из элементов следующего типа:
```Java
class Entry<K, V> {
    int hash;
    K key;
    V value;
    Entry next;
}
```
Один номер телефона займет 11 * 2 + 4 = 26байт. Одно полное имя - 
20 * 2 + 4 = 44байт. Тогда один экземпляр структры `Entry<K, V>` 
займет 4 + 26 + 44 + 4 = 78байт. 
Тогда вся мапа займет 18758328 * 78 + 4 = 1463149588 байт.